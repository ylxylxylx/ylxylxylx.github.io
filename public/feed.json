{
    "version": "https://jsonfeed.org/version/1",
    "title": "Alang' Blog",
    "home_page_url": "https://chennlang.github.io",
    "feed_url": "https://chennlang.github.io/feed.json",
    "description": "做自己的追风者~",
    "icon": "https://chennlang.github.io/favicon.ico",
    "author": {
        "name": "Alang' Blog",
        "url": "https://chennlang.github.io"
    },
    "items": [
        {
            "id": "https://chennlang.github.io/post/semantic-release/",
            "content_html": "<h2 id=\"前言\">前言</h2>\n<p>作为个人开发者，开源项目很简单，把代码提交到 github 公共仓库就 OK 了。<code>不过！要想维护好一个开源项目，并非易事</code>。</p>\n<h3 id=\"繁琐的发版流程\">繁琐的发版流程</h3>\n<p>一直以来，我都在使用 github 管理着自己的 npm 包，但随着开源项目使用的人越来越多，避免不了需要频繁发版。通常问题的修复流程如下：</p>\n<ol>\n<li>\n<p>修复 bug</p>\n</li>\n<li>\n<p>书写 CHANGE_LOG.md</p>\n</li>\n<li>\n<p>升级版本：修改 package.json 的 version 字段，v1.0.0 -> v1.0.1</p>\n</li>\n<li>\n<p>git commit 代码</p>\n</li>\n<li>\n<p>git 打版本 tag（v1.0.0 -> v1.0.1）</p>\n</li>\n<li>\n<p>发布 npm 包（npm login > npm publish）</p>\n</li>\n<li>\n<p>github Releases 发布新版本内容（新增 Releases， 编写内容，发布）</p>\n</li>\n</ol>\n<p><strong>这可能是所有个人开发者都在面临的问题，说实话，原本修复 bug 只需要改几行代码，不过接下来的发版的这一套流程...真的很难受。</strong></p>\n<h3 id=\"转机\">转机</h3>\n<p>这样问题，一直困扰着我，持续了很久。直到有一天，我真的受不了了，搜索发现了 <code>semantic-release</code> ，使用后发现它一键完成了我所有的需求。</p>\n<h3 id=\"写作目的\">写作目的</h3>\n<p>由于 <code>semantic-release</code> 相关的中文教程教程极少，官方文档对新人又不友好，遇到问题又很难通过搜索解决，在使用过程中真的是异常坎坷！</p>\n<p>你无法想象一个报错会困扰我一下午（上周在图书馆里焦头烂额一下午也没解决）。一度让我想换一个工具，不过没找大更合适的替代品。</p>\n<p>于是乎，有了这篇文章，<strong>我将完整的从 0-1 教会大家如何使用，还总结了我之前所遇到的所有问题。<code>我希望帮助更多人，让他们在使用这个工具的时候不至于浪费太多的时间!</code></strong></p>\n<h2 id=\"semantic-release-是什么\">semantic-release 是什么？</h2>\n<p><a href=\"https://semantic-release.gitbook.io/semantic-release\">semantic-release</a> 是一个全自动的版本管理和发布工具。它通过分析 commit 信息，从而自动完成：确认下一个版本号、修改版本、打 tag 、修改变更日志、自动发布等一系列流程。</p>\n<p>所以，<code>commit信息</code> 很关键，需要遵循以下原则：</p>\n<p>示例：当前版本是 v1.0.0</p>\n<ul>\n<li>\n<p>fix: xxxx ,三级版本号自动加 1，v1.0.0 --> v1.0.1</p>\n</li>\n<li>\n<p>feat: xxxx , 二级版本号自动加 1，v1.0.0 --> v1.1.0</p>\n</li>\n<li>\n<p>perf:xxx | BREAKING CHANGE:xxx, 一级版本号自动加 1，v1.0.0 --> v2.0.0</p>\n</li>\n</ul>\n<p>更多规范参考：<a href=\"https://github.com/angular/angular/blob/main/CONTRIBUTING.md#-commit-message-format\">Angular Commit Message Format</a> ,注意，除了以上类型，其他类型不会触发 release 流程。</p>\n<h2 id=\"本地安装\">本地安装</h2>\n<p>本文将使用 github + semantic-release 的方式完成自动化。当然，你也可以使用其他方式，例如 gitlab CICD 。本文就不详细介绍了，具体参考： <a href=\"https://semantic-release.gitbook.io/semantic-release/usage/ci-configuration\">CI Configuration | semantic-release</a>。</p>\n<h3 id=\"1-仓库中安装-semantic-release\">1. 仓库中安装 semantic-release</h3>\n<pre><code class=\"hljs language-shell\">npm install --save-dev semantic-release\n</code></pre>\n<h3 id=\"2-仓库中安装插件\">2. 仓库中安装插件</h3>\n<blockquote>\n<p>每一插件都有自己的作用，具体作用看下面的 .releaserc.js 说明，可以按需安装。</p>\n</blockquote>\n<pre><code>npm install --save-dev @semantic-release/commit-analyzer\nnpm install --save-dev @semantic-release/release-notes-generator\nnpm install --save-dev @semantic-release/changelog\nnpm install --save-dev @semantic-release/npm\nnpm install --save-dev @semantic-release/github\nnpm install --save-dev @semantic-release/git\n</code></pre>\n<h3 id=\"3-根目录下新建-releasercjs-文件\">3. 根目录下，新建 .releaserc.js 文件</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-comment\">// 这里改成你自己的仓库地址</span>\n  <span class=\"hljs-attr\">repositoryUrl</span>: <span class=\"hljs-string\">\"https://github.com/chennlang/walk-tree-list.git\"</span>,\n  <span class=\"hljs-attr\">branches</span>: [<span class=\"hljs-string\">\"master\"</span>], <span class=\"hljs-comment\">// 指定在哪个分支下要执行发布操作</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-comment\">// 1. 解析 commit 信息，默认就是 Angular 规范</span>\n    <span class=\"hljs-string\">\"@semantic-release/commit-analyzer\"</span>,\n    <span class=\"hljs-comment\">// 2. 生成发布信息</span>\n    <span class=\"hljs-string\">\"@semantic-release/release-notes-generator\"</span>,\n    <span class=\"hljs-comment\">// 3. 把发布日志写入该文件</span>\n    [\n      <span class=\"hljs-string\">\"@semantic-release/changelog\"</span>,\n      {\n        <span class=\"hljs-attr\">changelogFile</span>: <span class=\"hljs-string\">\"CHANGELOG.md\"</span>,\n      },\n    ],\n    <span class=\"hljs-comment\">// 4. 发布 NPM</span>\n    <span class=\"hljs-string\">\"@semantic-release/npm\"</span>,\n    <span class=\"hljs-comment\">// 5. 将变更发布到 GitHub Release</span>\n    <span class=\"hljs-string\">\"@semantic-release/github\"</span>,\n    <span class=\"hljs-comment\">// 6. 前面说到日志记录和版本号是新增修改的，需要 push 回 Git</span>\n    [\n      <span class=\"hljs-string\">\"@semantic-release/git\"</span>,\n      {\n        <span class=\"hljs-attr\">assets</span>: [<span class=\"hljs-string\">\"CHANGELOG.md\"</span>, <span class=\"hljs-string\">\"package.json\"</span>],\n      },\n    ],\n  ],\n};\n</code></pre>\n<h3 id=\"4-配置-github-action\">4. 配置 Github action</h3>\n<p>根目录下新建一个 .github/workflows/release.yml 文件，内容如下：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Release</span>\n\n<span class=\"hljs-comment\"># 当 master 分支被 push,就会触发</span>\n<span class=\"hljs-attr\">on:</span>\n  <span class=\"hljs-attr\">push:</span>\n    <span class=\"hljs-attr\">branches:</span> [<span class=\"hljs-string\">master</span>]\n<span class=\"hljs-comment\"># 权限</span>\n<span class=\"hljs-attr\">permissions:</span>\n  <span class=\"hljs-attr\">contents:</span> <span class=\"hljs-string\">write</span>\n  <span class=\"hljs-attr\">issues:</span> <span class=\"hljs-string\">write</span>\n  <span class=\"hljs-attr\">pull-requests:</span> <span class=\"hljs-string\">write</span>\n  <span class=\"hljs-attr\">packags:</span> <span class=\"hljs-string\">write</span>\n  <span class=\"hljs-attr\">id-token:</span> <span class=\"hljs-string\">write</span>\n\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">release:</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\n\n    <span class=\"hljs-attr\">steps:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">签出代码</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v3</span>\n        <span class=\"hljs-attr\">with:</span>\n          <span class=\"hljs-attr\">fetch-depth:</span> <span class=\"hljs-number\">0</span>\n          <span class=\"hljs-attr\">persist-credentials:</span> <span class=\"hljs-literal\">false</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">安装</span> <span class=\"hljs-string\">nodejs</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/setup-node@v2.5.2</span>\n        <span class=\"hljs-attr\">with:</span>\n          <span class=\"hljs-attr\">node-version:</span> <span class=\"hljs-string\">\"20.8.1\"</span> <span class=\"hljs-comment\"># node 版本</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">构建</span> <span class=\"hljs-string\">dist</span> <span class=\"hljs-comment\"># 构建，根据自己的仓库构建命令来</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|\n          npm install -g pnpm@latest-8\n          pnpm install\n          pnpm run build\n</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">发布</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">包</span>\n        <span class=\"hljs-attr\">env:</span>\n          <span class=\"hljs-attr\">GITHUB_TOKEN:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.PUBLISH_GH_TOKEN</span> <span class=\"hljs-string\">}}</span>\n          <span class=\"hljs-attr\">NPM_TOKEN:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.PUBLISH_NPM_TOKEN</span> <span class=\"hljs-string\">}}</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|\n          npm cache clean --force\n          npx semantic-release\n</span></code></pre>\n<h2 id=\"获取-token\">获取 TOKEN</h2>\n<p>要想通过 workflow 自动发布 npm 版本和提交版本变更信息，还需要去获得两个 TOKEN。</p>\n<ul>\n<li>\n<p><code>GITHUB_TOKEN</code>：授权后，能提交代码、打 tag、生成 变更信息。</p>\n</li>\n<li>\n<p><code>NPM_TOKEN</code>：授权后，不需要手动登录就能自动发布 npm 包。</p>\n</li>\n</ul>\n<h3 id=\"npm_token-获取流程\">NPM_TOKEN 获取流程</h3>\n<p>输入 https://www.npmjs.com/ ，登录你的 npm 账号后，点击头像，选择 Access Tokens。</p>\n<p>然后选择创建 <code>Classic Token</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241104164341.png\" alt=\"\"></p>\n<p>创建页面，输入名称，选择 <code>Publish</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241104164634.png\" alt=\"\"></p>\n<p>创建成功，将 token <code>复制并记录起来！后面要用到</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241104164742.png\" alt=\"\"></p>\n<blockquote>\n<p>如果你不想所有 npm 包都有权限，你还可以通过创建 Granular Access Token，更加细粒度的控制放开权限。</p>\n</blockquote>\n<h3 id=\"github_token-获取流程\">GITHUB_TOKEN 获取流程</h3>\n<p>登录 github 点击头像 》 选择 <code>Settings</code> 》 选择 <code>Developer settings</code>。</p>\n<p>选择 <code>Generate new token</code></p>\n<blockquote>\n<p>semantic-release 需要用到 github 仓库的读写权限，个人感觉 github 仓库的读写权限很敏感，最好别都放开。所以我这里创建一个只对某个仓库生效的 token.</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241104165627.png\" alt=\"\"></p>\n<p>创建页面-基础</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241104170553.png\" alt=\"\"></p>\n<p>创建页面-权限配置</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241104170849.png\" alt=\"\"></p>\n<p>权限有很多，需要修改的配置如下：</p>\n<ul>\n<li>\n<p><strong>Commit statuses</strong>: Read and write</p>\n</li>\n<li>\n<p><strong>Contents</strong> : Read and write</p>\n</li>\n<li>\n<p><strong>Deployments</strong>：Read and write</p>\n</li>\n<li>\n<p><strong>Issues</strong>： Read and write</p>\n</li>\n<li>\n<p><strong>Pull requests</strong>： Read and write</p>\n</li>\n</ul>\n<p>修改完成后，点击创建。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241104171600.png\" alt=\"\"></p>\n<p>创建成功，将 token <code>复制并记录起来！后面要用到。</code></p>\n<h2 id=\"github-仓库配置\">github 仓库配置</h2>\n<p>OK, 上面我们拿到了两个 token, 分别是 npm 创建的 token 和 github 创建的 token。接下来，我们需要将这两个 token 添加到你的 github 仓库的 <code>secrets</code> 里，这样，在运行 CI 流水线的时候，就能安全的读取到这两个 token。</p>\n<h3 id=\"配置-secrets\">配置 secrets</h3>\n<p>在目标仓库下，点击 Settings</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241104172414.png\" alt=\"\"></p>\n<p>创建好如下两个 secrets：</p>\n<ul>\n<li>\n<p><code>PUBLISH_GH_TOKEN</code> ：Name 别改，然后将之前在 github 创建好的 token 填进去。</p>\n</li>\n<li>\n<p><code>PUBLISH_NPM_TOKEN</code>：Name 别改，然后将之前在 npm 创建好的 token 填进去。</p>\n</li>\n</ul>\n<blockquote>\n<p>这里创建好的名称和 .github/workflows/release.yml 用到的名称要一致。如下</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">发布</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">包</span>\n        <span class=\"hljs-attr\">env:</span>\n          <span class=\"hljs-attr\">GITHUB_TOKEN:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.PUBLISH_GH_TOKEN</span> <span class=\"hljs-string\">}}</span> <span class=\"hljs-comment\"># 这里</span>\n          <span class=\"hljs-attr\">NPM_TOKEN:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.PUBLISH_NPM_TOKEN</span> <span class=\"hljs-string\">}}</span> <span class=\"hljs-comment\"># 这里</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|\n          npm cache clean --force\n          npx semantic-release\n</span></code></pre>\n</blockquote>\n<h3 id=\"配置-action-权限\">配置 action 权限</h3>\n<p>运行的 workflow 中需要调用一些仓库的权限是需要单独设置的，不然后出现 <code>403</code> 报错。</p>\n<p>在目标仓库下，点击 Settings，选择 Actions > General</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241105104530.png\" alt=\"\"></p>\n<p>Workflow permissions 勾如上选。其他可以不用管。</p>\n<h2 id=\"提交代码\">提交代码</h2>\n<p>最后，将本地的修改 push 到远程，就可以触发流水线自动开始部署了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20241104174014.png\" alt=\"\"></p>\n<h2 id=\"调试\">调试</h2>\n<p>如果你还在开发阶段，不确定配置能否在 github action 中正常运行，为了避免触自动发发版。我们可以使用 <code>dryRun</code> 模式。这个模式下将自动跳过发布、推送等动作，只校验配置是否正确，推送是否有权限。</p>\n<p>.releaserc.js</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"dryRun\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span> <span class=\"hljs-comment\">// 记得一切没问题后，设置为 false ！！！</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>如果我们还没准备好，只是想调试和测试 CI 运行是否正常，可临时添加这个配置，避免发版。</p>\n<p><a href=\"https://github.com/chennlang/walk-tree-list\">GitHub - chennlang/walk-tree-list: Traversing tree nodes</a> 这个是本次演示的仓库，里面有完整的配置，可以自行参考。</p>\n<h2 id=\"遇到的问题和解决方案\">遇到的问题和解决方案</h2>\n<h3 id=\"ci-执行时报错-403-无权限\">CI 执行时报错： 403 无权限</h3>\n<ul>\n<li>\n<p>检查是否有 <code>配置 action 权限</code>？</p>\n</li>\n<li>\n<p>检查 github token 权限，如果权限不够可以重新获取。</p>\n</li>\n</ul>\n<h3 id=\"ci-执行时报错没有推送权限-cannot-push-to-the-git-repository\">CI 执行时报错：没有推送权限 Cannot push to the Git repository.</h3>\n<pre><code class=\"hljs language-shell\">[10:03:25 AM] [semantic-release] › ✘  EGITNOPERMISSION Cannot push to the Git repository.\n</code></pre>\n<p>在 release.yaml 中添加如下权限</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-comment\"># 权限</span>\n<span class=\"hljs-attr\">permissions:</span>\n  <span class=\"hljs-attr\">contents:</span> <span class=\"hljs-string\">write</span>\n  <span class=\"hljs-attr\">issues:</span> <span class=\"hljs-string\">write</span>\n  <span class=\"hljs-attr\">pull-requests:</span> <span class=\"hljs-string\">write</span>\n  <span class=\"hljs-attr\">packags:</span> <span class=\"hljs-string\">write</span>\n  <span class=\"hljs-attr\">id-token:</span> <span class=\"hljs-string\">write</span>\n</code></pre>\n<h3 id=\"ci-执行时报错npm-err-cannot-read-properties-of-null-reading-matches\">CI 执行时报错：：npm ERR! Cannot read properties of null (reading 'matches')</h3>\n<p>报错原因：</p>\n<blockquote>\n<p>问题出在<code>npm@8</code>默认情况下 npm 处理工作区，因此在运行<code>npm version</code>npm 时，它将尝试更新<code>node_modules</code>所有工作区的，<code>package-lock.json</code>但由于我们使用 semantic-release，我们在 package.json 中提交的版本是假的（<code>0.0.0-semantic-release</code>），因此当 npm 尝试更新依赖关系树时，它无法检索<code>0.0.0-semantic-release</code>版本，因为它不再是我们工作区中引用的版本（因此默认情况下它会检查 NPM）。</p>\n<p>添加该选项<code>--no-workspaces-update</code>可防止 npm 考虑工作区</p>\n</blockquote>\n<p>官方说明参考：</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/semantic-release/npm/pull/482\">fix: do not update workspaces when applying new version by KillianHmyd · Pull Request #482 · semantic-release/npm · GitHub</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/semantic-release/npm/issues/495#issuecomment-1230379945\">no-workspaces-update option · Issue #495 · semantic-release/npm · GitHub</a></p>\n</li>\n</ul>\n<p>解决方案：在根目录添加 <code>.npmrc</code> 文件</p>\n<pre><code class=\"hljs language-shell\">workspaces = true\nworkspaces-update = false\n</code></pre>\n<h3 id=\"流水线执行成功却未发布新版本\">流水线执行成功，却未发布新版本</h3>\n<p>本质上，semantic-release 是通过 tag 来递增发版的。如果你之前的发版没有打 tag，semantic-release 第一次就会新增一个 tag 为 v1.0.0。而如果你的 package.json 版本是 1.4.0，那么就会有冲突。</p>\n<p>所以，解决方法就是，手动新建一个 tag v1.4.0，和当前仓库的 package.json version 要一致！然后新增 一个 commit 再 push。</p>\n<h3 id=\"不支持-monorepos-仓库\">不支持 Monorepos 仓库</h3>\n<p>semantic-release 作者明确表明，不计划支持 Monorepos 仓库。如果有需要，可以使用 <a href=\"https://github.com/pmowrer/semantic-release-monorepo\">GitHub - pmowrer/semantic-release-monorepo</a> 代替。</p>",
            "url": "https://chennlang.github.io/post/semantic-release/",
            "title": "GitHub + NPM 的自动化发版【Semantic Release 详细教程】",
            "date_modified": "2024-12-02T00:00:00.000Z",
            "author": {
                "name": "Alang' Blog",
                "url": "https://chennlang.github.io"
            }
        },
        {
            "id": "https://chennlang.github.io/post/react-pdf-downgrade/",
            "content_html": "<h2 id=\"背景\">背景</h2>\n<p>最近使用 <code>react-pdf</code> 进行 pdf 文件预览。上线后很长时间都没啥异常，不过一个突然下午，一个同事联系到我，说客户公司使用过程中发现文件预览页面无法打开。最初我也很纳闷，这么多客户使用了，都没问题，怎么现在突然有问题了。通过询问现场同事，才发现由于该客户的浏览器版本较低，项目中使用 react-pdf 预览 pdf 文件时，控制台提示语法错误 ：<code># SyntaxError: Unexpected token '||=' on version</code>，报错来源 <code>pdf.worker.min.js</code> 文件。</p>\n<h2 id=\"一问题复现\">一、问题复现</h2>\n<p>客户现场的机器没办法调试， 所以首先要能在本地复现这个错误才行，由于我本地用的是最新的 Chrome 浏览器，版本是 v123.0.6312.87 ，不会存在这个问题，也没法复现。所以考虑安装一个旧版本 Chrome 浏览器。因为之前遇到过 Chrome 79 下兼容问题，所以决定再下载一个测试试试。</p>\n<p>安装旧版本 Chrome 教程参考：</p>\n<blockquote>\n<p>mac 安装<code>Chrome</code> 79 参考了：<a href=\"https://blog.csdn.net/zjuwwj/article/details/139114749\">Mac 上如何安装低版本 chrome 浏览器_谷歌浏览器低版本下载安装包 mac-CSDN 博客</a></p>\n<p>./Google\\ Chrome --user-data-dir=$HOME/chrome-profile --chrome-version=79.0.3945.88</p>\n<p>禁止 mac Chrome 更新：</p>\n<p>cd ~/Library/Google</p>\n<p>sudo chown root:whell GoogleSoftwareUpdate</p>\n</blockquote>\n<p>下载完后 Chrome 79，果然，报错出现了，能复现就好办多了。</p>\n<h2 id=\"二问题分析\">二、问题分析</h2>\n<h3 id=\"1兼容性查询\">1、兼容性查询</h3>\n<p>从报错信息可知，是 <code>||=</code> 语法不支持，查询发现，确实，只能兼容到 85 版本</p>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_OR_assignment\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_OR_assignment</a></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/chennlang/doc-images/main/picGo/image.png\" alt=\"\"></p>\n<h3 id=\"2官网查询\">2、官网查询</h3>\n<p>接下来想到到 react-pdf github 官网找答案。很快，就发现官方有提及：就是将原来的 build 文件夹下的文件换成 legacy 下文件。从而兼容旧浏览器版本。</p>\n<p><a href=\"https://github.com/wojtekmaj/react-pdf?tab=readme-ov-file#legacy-pdfjs-worker\">GitHub - wojtekmaj/react-pdf: Display PDFs in your React app as easily as if they were images.</a></p>\n<p><img src=\"https://raw.githubusercontent.com/chennlang/doc-images/main/picGo/image-1.png\" alt=\"\"></p>\n<p>替换以后，<strong>还是不行！</strong> 同样的报错依然存在！</p>\n<blockquote>\n<p>一度让我怀疑是不是文件没换成功！结果多次确认确实换了。</p>\n</blockquote>\n<h3 id=\"3源码定位问题\">3、源码定位问题</h3>\n<p>这样看来很有可能是 pdfjs-dist/<code>legacy/</code>build/pdf.worker.min.js 这个文件兼容版本不够低呀，导致还是无法兼容 Chrome 79。</p>\n<p>索性直接看源码，这样定位问题无疑最快。在 github 找到 pdfjs-dist 库（pdf.js:）的源码，先看看它怎么打包的，在 ~/gulpfile.mjs 打包文件里发现了问题！</p>\n<p><a href=\"https://github.com/mozilla/pdf.js\">GitHub - mozilla/pdf.js: PDF Reader in JavaScript</a></p>\n<p><img src=\"https://raw.githubusercontent.com/chennlang/doc-images/main/picGo/image-2.png\" alt=\"\"></p>\n<p>可以看到，仅 pdfjs-dist 采用 webpack 进行打包，其中代码向下兼容仅支持到 Chrome >= 98。这就是为什么不支持 Chrome 79。</p>\n<h2 id=\"三解决问题\">三、解决问题</h2>\n<p>到此为止，问题就很清晰了，官方的 legacy worker 文件仅支持到 Chrome 98！现在我们就要想办法让它支持更低的浏览器版本。我们只需将 pdfjs-dist/<code>legacy/</code>build/pdf.worker.min.js 引入项目再次打包（因为项目配置是支持到 chrome 52 的）。</p>\n<p>我是 vite 项目，之前的 worker 文件引入方式是这样的：</p>\n<ul>\n<li>改动之前</li>\n</ul>\n<pre><code class=\"hljs language-js\">pdfjs.<span class=\"hljs-property\">GlobalWorkerOptions</span>.<span class=\"hljs-property\">workerSrc</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(\n  <span class=\"hljs-string\">\"pdfjs-dist/legacy/build/pdf.worker.min.js\"</span>,\n  <span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>\n).<span class=\"hljs-title function_\">toString</span>();\n</code></pre>\n<p>这样不会参与到 vite 的构建流程中，只会原样 copy 到 public 目录下。</p>\n<blockquote>\n<p>原因可以参考：<a href=\"https://cn.vitejs.dev/guide/assets.html\">静态资源处理 | Vite 官方中文文档</a></p>\n</blockquote>\n<ul>\n<li>引文文件修改成</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 加入打包</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"pdfjs-dist/legacy/build/pdf.worker.min.js\"</span>;\npdfjs.<span class=\"hljs-property\">GlobalWorkerOptions</span>.<span class=\"hljs-property\">workerSrc</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(\n  <span class=\"hljs-string\">\"pdfjs-dist/legacy/build/pdf.worker.min.js\"</span>,\n  <span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>\n).<span class=\"hljs-title function_\">toString</span>();\n</code></pre>\n<ul>\n<li>vite confg 文件修改</li>\n</ul>\n<pre><code class=\"hljs language-ts\">config = {\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-title function_\">react</span>(),\n    <span class=\"hljs-title function_\">legacy</span>({\n      <span class=\"hljs-attr\">targets</span>: [<span class=\"hljs-string\">\"chrome 52\"</span>], <span class=\"hljs-comment\">// 这是关键</span>\n      <span class=\"hljs-attr\">additionalLegacyPolyfills</span>: [<span class=\"hljs-string\">\"regenerator-runtime/runtime\"</span>],\n      <span class=\"hljs-attr\">renderLegacyChunks</span>: <span class=\"hljs-literal\">true</span>,\n    }),\n  ],\n  <span class=\"hljs-attr\">optimizeDeps</span>: {\n    <span class=\"hljs-attr\">include</span>: [<span class=\"hljs-string\">\"pdfjs-dist/legacy/build/pdf.worker.min.js\"</span>], <span class=\"hljs-comment\">// 强制构建</span>\n  },\n};\n</code></pre>\n<p>这样就能将 pdfjs-dist/legacy/build/pdf.worker.min.js 再次构建成更低的版本支持。测试后，页面正常渲染！</p>\n<h2 id=\"四预构建\">四、预构建</h2>\n<p>问题是解决了，不过 pdfjs-dist/legacy/build/pdf.worker.min.js 再次参与打包，明显增加了构建时间！大概多了一分钟，这个不能忍！是不是可以预构建一次，后续除了 react-pdf 版本升级，不然就不需要重新构建了。说干就干。</p>\n<h3 id=\"rollup-打包放弃\">rollup 打包（放弃）</h3>\n<p>一开始我使用 采用一个新的 vite.worker.confg 去单独打包 worker 文件，因为 vite 底层打包用的 rollup。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { defineConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"vite\"</span>;\n<span class=\"hljs-keyword\">import</span> legacy <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@vitejs/plugin-legacy\"</span>;\n<span class=\"hljs-keyword\">import</span> { legacyConfig } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./vite.config\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>({\n  <span class=\"hljs-attr\">build</span>: {\n    <span class=\"hljs-attr\">rollupOptions</span>: {\n      <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">\"node_modules/pdfjs-dist/build/pdf.worker.js\"</span>,\n      <span class=\"hljs-attr\">output</span>: {\n        <span class=\"hljs-attr\">dir</span>: <span class=\"hljs-string\">\"public/worker\"</span>,\n        <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">\"iife\"</span>,\n        <span class=\"hljs-attr\">entryFileNames</span>: <span class=\"hljs-string\">\"pdf.worker.js\"</span>,\n      },\n    },\n    <span class=\"hljs-attr\">copyPublicDir</span>: <span class=\"hljs-literal\">false</span>,\n  },\n  <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-title function_\">legacy</span>(legacyConfig)],\n});\n</code></pre>\n<p>package.json 中添加一下命令：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-attr\">\"build:worker\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"vite build --config vite.worker.config.ts\"</span><span class=\"hljs-punctuation\">,</span>\n</code></pre>\n<p>不过打包完又一些问题</p>\n<ol>\n<li>\n<p>会多生成一些 legacy 文件。</p>\n</li>\n<li>\n<p>打包需要指定 format: \"module\",原来的 pdf.worker.js 已经被打包成一个 iife,再次进行打包后，运行时发生某些错误。</p>\n</li>\n</ol>\n<p>基于上面的各种不确定性问题，确定放弃这种方式。</p>\n<h3 id=\"gulp-打包最终方案\">gulp 打包（最终方案）</h3>\n<p>回想我最初的目的，仅仅是想转换下 pdf.worker.js 的一些不兼容语法，脑海中突然浮现了 gulpjs ，一个流式的代码处理工具，做这个事情不就刚刚好！不会像 webpack 或者 rollup 这种封装过高的生产打包工具。</p>\n<p>实现：</p>\n<p>1、我们在根目录下新建一个 build 文件夹。执行以下命令：</p>\n<pre><code class=\"hljs language-shell\">mkdir build\ncd build\npnpm init\nnpm install --save-dev gulp gulp-babel @babel/core @babel/cli @babel/preset-env\n</code></pre>\n<p>2、新建 gulpfile.js 文件</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> gulp = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"gulp\"</span>);\n<span class=\"hljs-keyword\">const</span> babel = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"gulp-babel\"</span>);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">ENV_TARGETS</span> = [\n  <span class=\"hljs-string\">\"last 2 versions\"</span>,\n  <span class=\"hljs-string\">\"Chrome >= 52\"</span>,\n  <span class=\"hljs-string\">\"Firefox ESR\"</span>,\n  <span class=\"hljs-string\">\"Safari >= 16.4\"</span>,\n  <span class=\"hljs-string\">\"Node >= 18\"</span>,\n  <span class=\"hljs-string\">\"> 1%\"</span>,\n  <span class=\"hljs-string\">\"not IE > 0\"</span>,\n  <span class=\"hljs-string\">\"not dead\"</span>,\n];\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">transpilePdfWorker</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    gulp\n      <span class=\"hljs-comment\">// 输入</span>\n      .<span class=\"hljs-title function_\">src</span>(<span class=\"hljs-string\">\"../node_modules/pdfjs-dist/build/pdf.worker.js\"</span>)\n      .<span class=\"hljs-title function_\">pipe</span>(\n        <span class=\"hljs-comment\">// 兼容旧浏览器</span>\n        <span class=\"hljs-title function_\">babel</span>({\n          <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">\"@babel/preset-env\"</span>],\n          <span class=\"hljs-attr\">targets</span>: <span class=\"hljs-variable constant_\">ENV_TARGETS</span>,\n        })\n      )\n      <span class=\"hljs-comment\">// 输出</span>\n      .<span class=\"hljs-title function_\">pipe</span>(gulp.<span class=\"hljs-title function_\">dest</span>(<span class=\"hljs-string\">\"../public/worker\"</span>, { <span class=\"hljs-attr\">overwrite</span>: <span class=\"hljs-literal\">true</span> }))\n  );\n}\n\n<span class=\"hljs-comment\">// 导出默认任务</span>\n<span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">default</span> = transpilePdfWorker;\n</code></pre>\n<p>我们将 <code>../node_modules/pdfjs-dist/build/pdf.worker.js</code> 文件输入，并经过 babel 转换，最终输出到 <code>../public/worker</code> 文件夹里。</p>\n<p>3、接下来 替换 PdfPreviewer.tsx 组件里的引用方式</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Document</span>, <span class=\"hljs-title class_\">Page</span>, pdfjs } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-pdf\"</span>;\npdfjs.<span class=\"hljs-property\">GlobalWorkerOptions</span>.<span class=\"hljs-property\">workerSrc</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(\n  <span class=\"hljs-string\">\"/worker/pdf.worker.js\"</span>, <span class=\"hljs-comment\">// 从 public/worker 目录里读</span>\n  <span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>\n).<span class=\"hljs-title function_\">toString</span>();\n</code></pre>\n<p>经过测试，新的文件完美支持！</p>\n<h2 id=\"五css-文本显示层位置偏移解决\">五、css 文本显示层位置偏移解决</h2>\n<p>目前为止，pdf 文件是能正常预览了，不过，里面的 css 样式却不太对，具体表现为文字层与背景层没法对齐，错乱。经过分析，发现是引入的的 react-pdf 中的两个 css 文件也存在样式不兼容问题。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"react-pdf/dist/Page/AnnotationLayer.css\"</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"react-pdf/dist/Page/TextLayer.css\"</span>;\n</code></pre>\n<p>里面使用 css 的 <code>:is</code> ,这个方法仅支持到 Chrome 88，看来还得降级。\n<img src=\"https://raw.githubusercontent.com/chennlang/doc-images/main/picGo/image-3.png\" alt=\"\"></p>\n<p>降级方法和上的 js 类似，利用 gulp 和 postcss</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> postcss = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"gulp-postcss\"</span>);\n<span class=\"hljs-keyword\">const</span> postcssPresetEnv = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"postcss-preset-env\"</span>);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">genTranspileReactPdfCss</span>(<span class=\"hljs-params\"></span>) {\n    gulp\n      .<span class=\"hljs-title function_\">src</span>(<span class=\"hljs-string\">'../node_modules/react-pdf/dist/esm/Page/TextLayer.css'</span>)\n      .<span class=\"hljs-title function_\">pipe</span>(\n        <span class=\"hljs-title function_\">postcss</span>([\n          <span class=\"hljs-title function_\">postcssPresetEnv</span>({\n            <span class=\"hljs-attr\">features</span>: {\n              <span class=\"hljs-string\">\"custom-media-queries\"</span>: <span class=\"hljs-literal\">true</span>,\n              <span class=\"hljs-string\">\"nesting-rules\"</span>: <span class=\"hljs-literal\">true</span>,\n              <span class=\"hljs-string\">\"custom-selectors\"</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// 包括 :is() 支持</span>\n              <span class=\"hljs-string\">\"custom-properties\"</span>: <span class=\"hljs-literal\">true</span>,\n            },\n            <span class=\"hljs-attr\">browsers</span>: [\n              <span class=\"hljs-string\">\"last 2 versions\"</span>,\n              <span class=\"hljs-string\">\"Chrome >= 52\"</span>,\n              <span class=\"hljs-string\">\"Firefox ESR\"</span>,\n              <span class=\"hljs-string\">\"Safari >= 16.4\"</span>,\n              <span class=\"hljs-string\">\"Node >= 18\"</span>,\n              <span class=\"hljs-string\">\"> 1%\"</span>,\n              <span class=\"hljs-string\">\"not ie &#x3C;= 11\"</span>,\n              <span class=\"hljs-string\">\"not dead\"</span>,\n            ],\n          }),\n        ]),\n      )\n      .<span class=\"hljs-title function_\">pipe</span>(gulp.<span class=\"hljs-title function_\">dest</span>(<span class=\"hljs-string\">'../src/assets/pre-built'</span>, { <span class=\"hljs-attr\">overwrite</span>: <span class=\"hljs-literal\">true</span> }));\n  };\n}\n</code></pre>\n<p>然后项目更新一下引用的地址，指向预构建文件即可。到此为止，问题得以彻底解决！</p>\n<h2 id=\"六总结\">六、总结</h2>\n<p>浏览器兼容问题，一直都是前端绕不过的坎，开发过程中，往往我们会遇到很多类似问题。其实最简单最直接的方法就是让客户升级浏览器版本，不过大多数情况是，各方面安全原因，客户系统无法升级，浏览器版本也无法升级。所以我们不得不采用降级兼容的方案，来解决此类问题。处理此类问题的大致流程如下：</p>\n<ol>\n<li>\n<p>询问到尽可能多的用户环境信息：系统、屏幕分辨率、电脑型号、浏览器版本（重要）、网络环境。</p>\n</li>\n<li>\n<p>复现问题：拿到信息以后，尽量能在本地复现，这样方便调试，更快的定位和解决问题。否则，只能看看能否远程操作客户浏览器。</p>\n</li>\n<li>\n<p>定位问题：复现以后，通过控制台报错信息，网络请求里进行定位，可以根据常见问题依次排查定位。我一般的排查顺序如下：</p>\n<ul>\n<li>\n<p>前端静态文件是否正常加载？</p>\n</li>\n<li>\n<p>客户网关是否正常配置，页面内容是否正常返回？有时候 js 内容返回的是 html, 这就是网关没配对。</p>\n</li>\n<li>\n<p>接口是否有报错？</p>\n</li>\n<li>\n<p>是否出现跨域？</p>\n</li>\n</ul>\n</li>\n<li>\n<p>根据上面的定位，基本能发现具体问题，如果是兼容问题。可以参考以上方案就行降级操作。</p>\n</li>\n</ol>",
            "url": "https://chennlang.github.io/post/react-pdf-downgrade/",
            "title": "全面解析 React-PDF 的浏览器兼容性及其解决策略",
            "date_modified": "2024-10-25T00:00:00.000Z",
            "author": {
                "name": "Alang' Blog",
                "url": "https://chennlang.github.io"
            }
        },
        {
            "id": "https://chennlang.github.io/post/apple_11_to_iqoo_z9_turbo_plus/",
            "content_html": "<p>昨天晚上刚提了 IQOO z9 turbo+ ，我之前用的是苹果 11 ，是首发买的，6000 元，128g 国行。刚上手 IQOO 体验惊艳到了我。非广告，纯属记录一次买新手机的过程。</p>\n<p>我会从下面几个方面来阐述：</p>\n<p><strong>1 、价格</strong></p>\n<p>2668 买的顶配 16+512 （深圳手机补贴 9 折），本来看了苹果 16 pro ，512 存储的太贵了。一加 Ace3 pro 也考虑过，是曲屏，价格来到 3000 了，可选的太多了，例如次代旗舰小米 13 等，而 IQOO 2k 价位无敌，不考虑了，才 2k 多，早买早享受把。</p>\n<p><strong>2 、屏幕</strong></p>\n<p>相比苹果 11 画质提升很明显，1.5k 屏，144hz 高刷，看电影清晰多了、感受明显。不过缺点得习惯下 oled 屏幕，看久了眼睛疼，特别是晚上（现在还没适应，不过问题应该不大吧），苹果 11 led 之前不觉得有什么，相比 IQOO 眼睛看着还是舒服很多。</p>\n<p><strong>3 、外观</strong></p>\n<p>我选的白色，因为店里没有钛色现货了。不过白色也是很经典，耐看，直屏+很长，很精致。图片和实际上手真的区别很大，真的建议要自己去店里摸摸才知道喜欢不喜欢，我是很喜欢。然后是塑料外壳，这个真的对我来说是优点，看着和摸着都不像塑料。这就意味着后盖不会像苹果 11 那样会碎（我的苹果 11 已经自己手动换过 3 次玻璃后盖了，太痛苦了，拿着手机放在桌子上都是轻轻放下，生怕新换的玻璃后盖又坏了）。重量的话，还是很轻，比我老婆的苹果 14pro 轻很多。</p>\n<p><strong>4 、AI</strong></p>\n<p>从 iOS 换到了安卓 vivo 系统，真的感叹国产手机进步的太快了，vivo 手机尽然有 AI ，语音助手、屏幕识别、作文帮写、等集成到了手机里，还以为苹果 16 是新创，结果 vivo 早有了。哈哈，目前国行 16 还不支持 AI ，我已经提前替果粉用上 AI 了。</p>\n<p><strong>流畅性</strong></p>\n<p>苹果系统当然很流畅，动画过渡还是领先很多的。不过 vivo 系统我感觉也非常不错，精简、整洁，不会有很多花里胡哨的各种设置，把常用的功能都放在显眼的地方，很方便，轻松上手，没有学习成本，这也是出乎我意料的。</p>\n<p><strong>6 、信号</strong></p>\n<p>我认为这是手机最基本的功能，也是我现在换手机最看重的点。苹果信号太差了，我的苹果 11 和老婆的 苹果 14pro 信号都不是很好，刚好马上国庆要坐高铁，想到高铁上两个苹果手机只能用来看看时间，就更加坚定要换一个安卓手机。（这几天还一直在看随身 wifi, 不过要不就是要买个流量卡（不想买，套餐贵），要不就把自己的卡插上去，就收不到电话短信，都不方便，还得随时额外带个东西出门。）</p>\n<p>国产手机看过评测，加上之前也用过 vivo ,信号都不错。IQOO 拿到手插上卡到现在，信号真的好太多。我的流量卡是每月 20g,然后超出降速到 1M 网速，正好现在降速了测试了下，在公司（苹果信号很差）还能下载 app, 而且速度也不慢。之前苹果 11 是完全不可能的，也有可能 苹果 11 只支持 4G ，不清楚。</p>\n<p><strong>7 、拍照</strong></p>\n<p>这个拍照我觉得确实一般，色彩偏饱和，然后暗部压的很深，可能是为了保留高光细节，夜晚也有噪点。优点：人像美颜不错，磨皮很自然。这是 vivo 手机的强项！ vivo 可是人像出家的呀。\n总结：对我来说，旅游的时候，我一般不会用自己手机拍照，我有相机（或者老婆的苹果 14 pro ）完全够用。平时，手机只是用来记录生活，只需要拍清，能看到就好了，并不需要吹毛求疵。</p>\n<p><strong>8 、保修</strong></p>\n<p>官方保修一年，然后花了 149 买了两年的碎屏险，真的很便宜，这两年我可以完全不贴钢化膜，因为店员说了 2 年到期了可以免费换，及时屏幕没坏。也询问了店员自费维修屏幕的价格，是 900 。那就更应该买了。</p>\n<p><strong>总结</strong></p>\n<p>使用苹果手机以来，我一直追求的是稳定，流畅，不玩游戏、不刷抖音（因为苹果不适合玩游戏，发热掉帧），也一直在自洽，告诫自己要成熟，不能玩游戏了，刷视频也不好。渐渐的感觉我已经对游戏、手机、电子产品都失去的兴趣，也就是所谓的“电子阳痿”。直到昨晚我在地铁上刷到了 IQOO z9 turbo+ 的视频，我直接兴奋了，这价格，这配置！下了地铁我快步走到了附近了 vivo 自营店，看到了真机，打量着外观，也摸了手感，真的喜欢。这么久了，第一次对一个东西有那种渴望，想要，就好像认定了这个手机一定是我的，或者说已经是我的了，就等着我拿走。回到家，匆忙着吃完晚饭，我就拉着老婆到店里直接下单了，过程中也遇到一个小哥，可能还在读书，也是买了这款手机，看到他，就好像看到了之前的自己，那种对新手机，新技术的着迷。</p>\n<p>当然，我也不知道我的新鲜感会保持多久，会不会又回到和之前一样。但此时，这个手机真的给我带来了很多快乐。因为它性能好，我可能会更愿意用它去尝试一些没玩过游戏。因为它的存储大，我更愿意下载更多的软件，而不需要为容量焦虑了。</p>\n<p>最后顺便说一下我升级的手机条件：\n1 、屏幕好点：苹果 11 平时使用没问题，像素不到 1080p ，看高清视频还是能感受到不清晰。\n2 、续航好点：苹果 11 一天至少 2 充\n3 、有高刷：这个感受不明显，有最好。\n4 、信号要好：硬性要求，太影响实际使用体验了。</p>\n<p>手机我才拿到，可能现在说的可能大多数是优点，因为它真的满足了我所有的升级条件，而且价格是我能闭眼入的水平。后续再慢慢分享更多使用体验。</p>\n<hr>\n<p><strong>换安卓 1 天后感受</strong></p>\n<p>1 、微信来消息有弹窗提示了！\n2 、去以前苹果 11 没信号的地方，新手机竟然能流畅刷视频，绝了。\n3 、简单试玩了下崩坏 3 ，没有一点卡顿。发热明显，不过占时没发现掉帧。</p>\n<p>缺点：\n1 、安卓和苹果底层的动画不同，即便全程 144hz ，有些 APP 并没适配，还是会感觉卡卡的。小问题</p>\n<hr>\n<p><strong>145 天后感受</strong></p>\n<ol>\n<li>信号：分地区和手机卡，深圳比苹果信号好，重庆则相反。</li>\n<li>续航：非常不错，出去玩一天完全不用考虑要不要带充电宝。</li>\n<li>系统：卡死的情况，有，很少。</li>\n<li>相机：单纯拍人像够用，出片率高，美颜自然好看。视频就算了。</li>\n</ol>",
            "url": "https://chennlang.github.io/post/apple_11_to_iqoo_z9_turbo_plus/",
            "title": "记录：苹果 11 换 IQOO z9 turbo+",
            "date_modified": "2024-09-26T00:00:00.000Z",
            "author": {
                "name": "Alang' Blog",
                "url": "https://chennlang.github.io"
            }
        },
        {
            "id": "https://chennlang.github.io/post/js-analyzer-come/",
            "content_html": "<h3 id=\"终于有勇气发布了\">终于有勇气发布了~</h3>\n<p>我一直认为它只是一个不完美的半成品，所以我只是悄悄的上架到了个人的 github 仓库，并没打算公之于众。不过就在今天，我意外的发现仓库多了一个陌生人的 Issue，真的很震惊，我没想到真的有人安装文档安装使用了。这真的让我感到意外，也许真的有人觉得有用，那么我就要做好它，也有责任做好它！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20240131144614.png\" alt=\"\"></p>\n<h2 id=\"前言\">前言</h2>\n<p>从事开发工作以来，很多时候我们除了开发业务代码以外，更多时候是在想如何优化自己的代码。在这个过程中，交叉的依赖关系以及不清楚修改后影响的范围，这特别是对于还不熟悉项目的<code>新人</code>，每一步都走得<code>小心翼翼</code>。</p>\n<p>在开发工作中，因为修改某个文件导致其他引用它的模块出现问题的现象屡见不鲜。至此，我一直在寻找一个依赖分析工具，能帮我快速高效的理清项目的框架、依赖关系，模块的引用上下文。</p>\n<h2 id=\"现存方案\">现存方案</h2>\n<p>为此，我也找了很多开源的分析工具，不过让我很失望，类似的工具不多，而且它们都是命令行工具，想要分析不同模块的依赖需要多次执行不同的代码，分析结果也只是一个 json 文件或者依赖图片。json 文件和 png 图都是“死的”，它们只是某一个依赖关系的<code>临时快照</code>，不具备<code>实时性</code>，也不能显示模块更多<code>上下文</code>信息。</p>\n<ul>\n<li><a href=\"https://github.com/sverweij/dependency-cruiser\">Dependency cruiser</a>验证和可视化依赖关系</li>\n<li><a href=\"https://github.com/pahen/madge\">Madge</a>生成模块依赖关系的可视化图表</li>\n<li><a href=\"https://github.com/auchenberg/dependo\">dependo</a>可视化 CommonJS、AMD 或 ES6 模块依赖关系</li>\n<li><a href=\"https://github.com/aserg-ufmg/JSCity\">JSCity</a>将 JavaScript 源代码可视化为可导航的 3D 城市</li>\n<li><a href=\"https://github.com/hughsk/colony\">colony</a>表示 Node.js 代码及其依赖项之间链接的浏览器内集群<a href=\"https://github.com/hughsk/colony\">图</a></li>\n<li><a href=\"https://github.com/remojansen/TsUML\">TsUML</a>从 TypeScript 源代码生成 UML 图</li>\n</ul>\n<blockquote>\n<p>写文章时在 GitHub 发现一个工具 [knip](<a href=\"https://github.com/webpro/knip\">GitHub - webpro/knip: ✂️ Find unused files, dependencies and exports in your JavaScript and TypeScript projects. Knip it before you ship it!</a>)，它可以帮你发现未依赖的文件，我的这个工具其实囊括了它里面很多功能，使用起来会更简单。参考应用场景 4 和场景 5。</p>\n</blockquote>\n<h2 id=\"想法萌生\">想法萌生</h2>\n<p>所以，我相信不止我一个人在重构的过程中遇到过如上问题，至此，我决定要开发一个依赖分析工具，解决上面的所有问题，而且还必须做得更好，有 UI 界面操作，可交互，能动态切换分析文件，还能展示更多的模块关联信息。</p>\n<h2 id=\"开始做产品\">开始做产品</h2>\n<p>自己做产品，真的是很酷的事情。三年前，我终于开始的我的依赖分析工具开发之路。我的初步想法是这样的，服务端生成依赖数据，前端负责可视化展示依赖关系。下面是架构图：核心的流程就是服务端对不用的文件分析，通过 AST 解析从而收集到文件中的依赖信息，然后再将这些依赖关系梳理清洗整合，最终生成一个物料包给到前端展示。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/20240131144710.png\" alt=\"\"></p>\n<h2 id=\"它来了\">它来了</h2>\n<p>时隔快三年，我利用业余时间间断的开发，终于完成了核心分析功能，并不是因为这些功能很多，需要花费这么多的时间，而是有如下两个原因：\n其一：业余时间开发，时间本就不固定，我也只是当做业务爱好来做；\n其二：中间有一段时间开发停止了，那段时间我怀疑自己做的产品是不是真的有用，是否真的能帮助到别人，是不是一件有意义的事情。</p>\n<p>最后，我想通了，一定有需要它的人，不能放弃，2024 年<code>它来了</code>!</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/971BBD8C-FC2F-4EB9-9A1E-5B64FC7581F2.jpg\" alt=\"\"></p>\n<h2 id=\"产品功能优势\">产品功能/优势</h2>\n<p>一个可视化可交互的 Web 文件依赖分析工具，跨框架,可用于 Vue React Svelte Angular Node 等前端项目</p>\n<ul>\n<li>\n<p>基于 AST 语法分析， 可交互的一体化<code>可视化</code>依赖分析系统</p>\n</li>\n<li>\n<p>支持切换分析入口文件。</p>\n</li>\n<li>\n<p>支持<code>依赖反转</code>。</p>\n</li>\n<li>\n<p>支持显示文件被引用次数，以及引用地址。</p>\n</li>\n<li>\n<p>支持显示文件的导出变量被引用信息。</p>\n</li>\n<li>\n<p>适用于 ES6、CommonJs。</p>\n</li>\n<li>\n<p>支持的文件类型：JS、TS、JSX、TSX、Vue、Sass、Less、Css、html。</p>\n</li>\n<li>\n<p>支持 package 依赖分析。</p>\n</li>\n<li>\n<p>支持未引用 文件、npm 包 分析。</p>\n</li>\n<li>\n<p><code>非常安全</code>：所有文件本地存储，不涉及联网和上传 。</p>\n</li>\n<li>\n<p>支持使用默认编辑器打开文件和<code>文件预览</code>。</p>\n</li>\n<li>\n<p>支持<code>暗黑模式</code>。</p>\n</li>\n</ul>\n<h3 id=\"快速开始\">快速开始</h3>\n<p>🔥 🔥 🔥 <a href=\"https://github.com/chennlang/js-analyzer\">Github 仓库</a></p>\n<p>🔥 🔥 🔥 [Demo 演示](<a href=\"https://chennlang.github.io/js-analyzer/#/file-chart\">JsAnalyzer | 依赖分析工具 Demo</a>)</p>\n<p>如果觉得还不错，或者对你有帮助，别忘了点一下 Star 哦~</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"bash\">1. 全局安装</span>\nnpm install @js-analyzer/server -g\n<span class=\"hljs-meta prompt_\">\n# </span><span class=\"bash\">2. 进入到需要分析得项目根目录</span>\ncd /xxx/project\n<span class=\"hljs-meta prompt_\">\n# </span><span class=\"bash\">3. 指定当前项目并启动</span>\njs-analyzer --root ./\n</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/858FD797-462C-40E2-9191-EBD015F5302F.png\" alt=\"\"></p>\n<p>接下来，访问链接就能看到了！</p>\n<blockquote>\n<p>默认配置不一定适合你的项目，请告诉工具更多信息，会使分析结果更加准确</p>\n<p><a href=\"https://github.com/chennlang/js-analyzer#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">详细配置请点击</a></p>\n</blockquote>\n<h2 id=\"图文介绍\">图文介绍</h2>\n<p>左侧菜单有四个，依次是：<code>文件依赖分析</code>、<code>npm 包依赖分析</code>、<code>变量热图</code>、<code>未知引用文件</code></p>\n<p>其他的页面功能比较简单，这里我重点讲一下 <code>文件依赖分析</code>页面的功能，也是整个工具最核心的功能。</p>\n<h3 id=\"关系图-文件夹关系图\">关系图-文件夹关系图</h3>\n<p>点击左侧目录树，如果点击的是文件夹，则显示 <code>文件夹关系视图</code>，点击的是文件则显示 该文件的<code>被依赖视图</code>。</p>\n<p>显示文件夹下的所有文件依赖关系，图标中节点的大小表示被依赖的次数，节点越大，依赖的次数就越多。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/B4855AF6-CD5D-4E5A-9F8B-90735719D42C.png\" alt=\"\"></p>\n<h3 id=\"关系图-被依赖视图\">关系图-被依赖视图</h3>\n<p>双击某个节点，可进入该节点的<code>被依赖视图</code>，显示当前文件被哪些文件依赖。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/971BBD8C-FC2F-4EB9-9A1E-5B64FC7581F2.jpg\" alt=\"\"></p>\n<h3 id=\"关系图-依赖视图\">关系图-依赖视图</h3>\n<p>双击某个节点，可进入该节点的<code>被依赖视图</code>，然后点击左上角视图切换图标，第二个，则显示 <code>依赖视图</code>。显示当前文件依赖了哪些文件。</p>\n<h3 id=\"关系图-上游依赖图\">关系图-上游依赖图</h3>\n<p>双击某个节点后（处于<code>被依赖视图</code>），再点击左上角的正数第三个图标，切换成 上游依赖图</p>\n<p>，显示该文件，所有上游的依赖文件视图。</p>\n<blockquote>\n<p>上游依赖图，我研究了很多展示的图形，路径图、环形图、力导向图。模块的引用关系是无序的，混乱的，这会使的展示的图形错中复杂，看起来很费劲，最后综合性能和显示效果，选择了力导向图，这个布局算法非常有趣，是基于物理模型，即将图形视为一个力学系统，节点作为物体，边作为弹簧或者电磁力之类的力（吸引或排斥），然后通过模拟力的作用来计算图的布局。</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/7A253682-5DE3-49C9-AA26-CAB6F6B214D6.jpg\" alt=\"\"></p>\n<h3 id=\"包管理\">包管理</h3>\n<p>显示当前仓库下 npm 包，展示包引用次数大小，引用详情。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/5851A9D0-D818-4032-8761-68DEFA944310.jpg\" alt=\"\"></p>\n<h3 id=\"热词\">热词</h3>\n<p>显示仓库中使用频率较高的变量名和方法名，方便新人遵循命名规范。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/AFA06051-4453-4EAC-AC8E-D88DF8A9754C.jpg\" alt=\"\"></p>\n<h3 id=\"隐式引用未知引用\">隐式引用（未知引用）</h3>\n<p>我们在引用模块时，有些并没有定义或者在 npm 中显示安装，对于新人来说，这会造成不必要的困扰。点击可以查看引用的文件和详细信息。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/88C9BEBF-AFC7-4929-A2FC-6D482EBD82B9.jpg\" alt=\"\"></p>\n<h3 id=\"依赖详情\">依赖详情</h3>\n<p>所有图表节点单击后，都能打开引用详情弹出。展示引用的具体文件和变量。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/58270D68-5FC3-48F6-966D-D39E77CA6F9B.png\" alt=\"\"></p>\n<h4 id=\"代码预览\">代码预览</h4>\n<p>文件后的预览，显示代码预览信息。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/chennlang/doc-images//picGo/4515F259-52BB-4D80-9ABC-51FC01CE83E6.png\" alt=\"\"></p>\n<h4 id=\"编辑器打开\">编辑器打开</h4>\n<p>点击预览后面的跳转按钮将跳转到编辑器里打开。</p>\n<h3 id=\"更多\">更多</h3>\n<p>其实还有很多细节功能，就不一一列举出来了，欢迎大家去探索出更多的彩蛋。</p>\n<h2 id=\"应用场景\">应用场景</h2>\n<ol>\n<li>确定影响范围：发现某个组件存在问题，然而不清楚该组件被多少页面引用了，怕影响到其他页面。</li>\n</ol>\n<blockquote>\n<p>使用工具后：修改完文件模块，我们可以使用上游依赖分析视图，看到所有引用该组件的业务。</p>\n</blockquote>\n<ol start=\"2\">\n<li>提取公共组件：团队中存在公共组件库、统计一下业务项目中用到多的组件，提取到公共组件库</li>\n</ol>\n<blockquote>\n<p>使用工具后：在文件夹视图，能看到根目录/某个目录下所有组件的被引用次数，次数多的组件就可以抽离到组件库了。</p>\n</blockquote>\n<ol start=\"3\">\n<li>单元测试：被引用次数多的模块往往需要非常稳定，对其添加单元测试是非常有必要的</li>\n</ol>\n<blockquote>\n<p>使用工具后：在文件夹视图，能看到哪些模块/文件被引用次数最多。</p>\n</blockquote>\n<ol start=\"4\">\n<li>\n<p>未使用文件删除：项目中存在大量的未使用文件，可以查看被依赖次数，被引用为 0 则表示可以删除。</p>\n</li>\n<li>\n<p>未使用的导出删除：单个文件内 exports 的模块，也可以看到其被引用情况，如果未被引用，可以考虑删除。</p>\n</li>\n</ol>\n<blockquote>\n<p>点击图表中单个文件节点，会显示文件的详细信息弹窗，里面有每个导出模块的引用关系。</p>\n</blockquote>\n<ol start=\"6\">\n<li>大家可以自己去发现更多场景.....</li>\n</ol>\n<h2 id=\"后续规划\">后续规划</h2>\n<ul>\n<li>\n<p>查看循环依赖分析。</p>\n</li>\n<li>\n<p>显示模块稳定性指标分析。</p>\n</li>\n<li>\n<p>可以定位到引用代码具体行、列，目前只支持定位到文件。</p>\n</li>\n<li>\n<p>页面可预览文件的代码，实现不依赖编辑器快速查看依赖上下文。</p>\n</li>\n</ul>\n<p>想要做的真的很多很多，不过现在工作比较忙，没有时间和精力继续添加新功能，写此文章的主要目的也是希望有更多感兴趣的人加入进来。</p>\n<h2 id=\"结尾\">结尾</h2>\n<p><code>脑海困缠自斟酌，莫忘心中自由花。</code>不要总是陷入自己思维的纠结中，放下束缚，相信自己的内心自由与激情，勇敢追寻自己的梦想和目标吧！</p>\n<p>最后，如果觉得用着还不错，记得留下你的 star , 🔥  <a href=\"https://github.com/chennlang/js-analyzer\">Github 仓库</a> 🔥 这对我有很大帮助。</p>",
            "url": "https://chennlang.github.io/post/js-analyzer-come/",
            "title": "【js-analyzer】时隔三年，一个可视化可交互的前端依赖分析工具发布了",
            "date_modified": "2024-01-31T00:00:00.000Z",
            "author": {
                "name": "Alang' Blog",
                "url": "https://chennlang.github.io"
            }
        },
        {
            "id": "https://chennlang.github.io/post/what-flip/",
            "content_html": "<h2 id=\"flip-是什么\">FLIP 是什么？</h2>\n<p>flip 并不是一个插件或者一个库，仅仅是一个动画实现的思路。例如 <code>Vue</code>的内置组件 <code>transitionGroup</code> 就有用到。</p>\n<h2 id=\"作用\">作用</h2>\n<p>那么 flip 有什么用呢？一般情况我们给元素设置动画，都是提前知道开始和结束状态，例如设置一个从左到右的循环移动动画。我们是知道开始位置（0,0），结束位置为（200，0）。然后就可以通过如下方案实现：</p>\n<p><img src=\"https://raw.githubusercontent.com/chennlang/doc-images/main/picGo/Kapture%202022-09-13%20at%2011.31.51.gif\" alt=\"移动\"></p>\n<h3 id=\"方案-1\">方案 1：</h3>\n<p>css 实现</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"box\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n</code></pre>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-id\">#box</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100px</span>;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n  <span class=\"hljs-attribute\">animation</span>: move <span class=\"hljs-number\">1s</span> linear infinite;\n}\n\n<span class=\"hljs-keyword\">@keyframes</span> move {\n  <span class=\"hljs-number\">0%</span> {\n    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translateX</span>(<span class=\"hljs-number\">0px</span>);\n  }\n  <span class=\"hljs-number\">100%</span> {\n    <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translateX</span>(<span class=\"hljs-number\">200px</span>);\n  }\n}\n</code></pre>\n<h3 id=\"方案-2\">方案 2：</h3>\n<p>js 实现</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> box = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"box\"</span>);\nbox.<span class=\"hljs-title function_\">animate</span>(\n  [{ <span class=\"hljs-attr\">transform</span>: <span class=\"hljs-string\">`translateX(0px)`</span> }, { <span class=\"hljs-attr\">transform</span>: <span class=\"hljs-string\">\"translateX(200px)\"</span> }],\n  {\n    <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">1000</span>,\n    <span class=\"hljs-attr\">iterations</span>: <span class=\"hljs-title class_\">Infinity</span>,\n  }\n);\n</code></pre>\n<h3 id=\"存在问题和解决思路\">存在问题和解决思路</h3>\n<p><strong>如果事先我们并能提前知道结束状态该怎么办呢？</strong> 例如一个随机的位移。我们要如何实现位移动画？或者从一种形态变成另一种未知形态。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">randomNumber</span>(<span class=\"hljs-params\">min, max</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * (max - min + <span class=\"hljs-number\">1</span>) + min, <span class=\"hljs-number\">10</span>);\n}\n\n<span class=\"hljs-keyword\">const</span> rand = <span class=\"hljs-title function_\">randomNumber</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// 随机数</span>\nbox.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">transform</span> = <span class=\"hljs-string\">`translateX(<span class=\"hljs-subst\">${rand}</span>px)`</span>;\n</code></pre>\n<p>所以我们就可以设想，对于任意一个元素发生改变，如果在页面渲染前我们能拿到元素的开始和结束状态信息，并通过 js <code>animate</code> API 设置动画，此时页面再渲染，不就可以实现了吗? 这其实就是 flip 的原理。</p>\n<h2 id=\"flip-基础概念\">FLIP 基础概念</h2>\n<p><code>FLIP</code>代表<code>First</code>和<code>Last</code>以及<code>Invert</code>还有<code>Play</code>四个单词的组合。</p>\n<ul>\n<li>\n<p>First 初始状态</p>\n</li>\n<li>\n<p>Last 最终状态</p>\n</li>\n<li>\n<p>Invert 回到初始状态</p>\n</li>\n<li>\n<p>Play 执行动画</p>\n</li>\n</ul>\n<h2 id=\"原理\">原理</h2>\n<p>记录目标元素开始和结束位置信息，在下一帧页面渲染前添加动画。也就是说再我们改变元素的属性后与浏览器实际渲染前有一个<code>空档期</code>,在 <code>空档期</code>我们可以拿到变化后的元素信息。</p>\n<p>事实上每一次 UI 视图更新都会提前清空当前任务队列中的微任务和执行<code>requestAnimationFrame</code>回调。这两个地方都能拿到变化后的元素信息。下图可以更加直观的解释</p>\n<p><img src=\"https://raw.githubusercontent.com/chennlang/doc-images/main/picGo/202502181636868.png\" alt=\"\"></p>\n<p>这里我们用一个简单的例子证实：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> box = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"box\"</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"old:\"</span>, box.<span class=\"hljs-title function_\">getBoundingClientRect</span>());\n\n<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"then:\"</span>, box.<span class=\"hljs-title function_\">getBoundingClientRect</span>());\n});\n<span class=\"hljs-title function_\">requestAnimationFrame</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"req:\"</span>, box.<span class=\"hljs-title function_\">getBoundingClientRect</span>());\n});\n</code></pre>\n<p>结果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/chennlang/doc-images/main/picGo/202502181637928.png\" alt=\"\"></p>\n<p>上面的结果不仅证实了微任务和 <code>requestAnimationFrame</code> 能拿到更新后的元素信息，也能看出微任务是在 <code>requestAnimationFrame</code> 前面执行。具体的宏任务、微任务、动画执行原理，可以看看这篇文章，写的很好：<a href=\"https://juejin.cn/post/6844904165462769678\" title=\"https://juejin.cn/post/6844904165462769678\">《深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调》</a>，这里就不过多赘述了。</p>\n<p>既然能提前拿到变化后的元素信息，那我们就可以使用上面 <code>方案2</code> 来实现动画了。</p>\n<p>这里我们还是用一个随机位置变化的案例来演示，这次使用 flip 动画来实现：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">randomNumber</span>(<span class=\"hljs-params\">min, max</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * (max - min + <span class=\"hljs-number\">1</span>) + min, <span class=\"hljs-number\">10</span>);\n}\n\n<span class=\"hljs-keyword\">const</span> box = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"box\"</span>);\n<span class=\"hljs-keyword\">const</span> oldPosition = box.<span class=\"hljs-title function_\">getBoundingClientRect</span>();\n\n<span class=\"hljs-comment\">// 随机设置一个新的位置</span>\nbox.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">left</span> = <span class=\"hljs-title function_\">randomNumber</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1000</span>) + <span class=\"hljs-string\">\"px\"</span>;\nbox.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">top</span> = <span class=\"hljs-title function_\">randomNumber</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1000</span>) + <span class=\"hljs-string\">\"px\"</span>;\n\n<span class=\"hljs-comment\">// 微任务中设置动画</span>\n<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">resolve</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> newPosition = box.<span class=\"hljs-title function_\">getBoundingClientRect</span>();\n  <span class=\"hljs-keyword\">const</span> options = {\n    <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">300</span>,\n    <span class=\"hljs-attr\">easing</span>: <span class=\"hljs-string\">\"cubic-bezier(0,0,0.32,1)\"</span>,\n  };\n  box.<span class=\"hljs-title function_\">animate</span>(\n    [\n      { <span class=\"hljs-attr\">transform</span>: <span class=\"hljs-string\">`translateX(-<span class=\"hljs-subst\">${newPosition.x}</span>px)`</span> },\n      { <span class=\"hljs-attr\">transform</span>: <span class=\"hljs-string\">\"translateX(0)\"</span> },\n    ],\n    options\n  );\n});\n</code></pre>\n<blockquote>\n<p>这里要特别注意，<code>box.animate</code> 是从新的位置为开始关键帧，旧的位置为结束关键字，故上面动画相当于从过去的状态到新的状态的回放，因为正常 UI 更新是瞬间完成的，自定义的动画其实是在完成之后执行的，有点障眼法的意思。</p>\n</blockquote>\n<h2 id=\"案例\">案例</h2>\n<p>目标：点击商品进入商品详情页面，动画类似从某个商品卡片进入详情的视觉效果</p>\n<p><img src=\"https://raw.githubusercontent.com/chennlang/doc-images/main/picGo/Kapture%202023-02-10%20at%2014.43.21.gif\" alt=\"\"></p>\n<ul>\n<li>list.html</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&#x3C;!DOCTYPE <span class=\"hljs-keyword\">html</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">head</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"IE=edge\"</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">title</span>></span>List<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">title</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">style</span>></span><span class=\"css\">\n      * {\n        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;\n      }\n      <span class=\"hljs-selector-class\">.list</span> {\n        <span class=\"hljs-attribute\">margin-top</span>: <span class=\"hljs-number\">100px</span>;\n        <span class=\"hljs-attribute\">display</span>: flex;\n        <span class=\"hljs-attribute\">flex-wrap</span>: wrap;\n      }\n      <span class=\"hljs-selector-class\">.list-item</span> {\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">33.33%</span>;\n        <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">200px</span>;\n        <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">200px</span>;\n        <span class=\"hljs-attribute\">text-align</span>: center;\n        <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#ccc</span>;\n        <span class=\"hljs-attribute\">color</span>: blue;\n        <span class=\"hljs-attribute\">cursor</span>: pointer;\n        <span class=\"hljs-attribute\">box-sizing</span>: border-box;\n      }\n    </span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">style</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">head</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">body</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list\"</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list-item\"</span>></span>商品1<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list-item\"</span>></span>商品2<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list-item\"</span>></span>商品3<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list-item\"</span>></span>商品4<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list-item\"</span>></span>商品5<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"list-item\"</span>></span>商品6<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">body</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">\".list\"</span>).<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">\"click\"</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =></span> {\n      <span class=\"hljs-keyword\">const</span> { x, y, width, height } = e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-title function_\">getBoundingClientRect</span>();\n\n      <span class=\"hljs-comment\">// 跳转到详情页面</span>\n      location.<span class=\"hljs-property\">href</span> = <span class=\"hljs-string\">`./detail.html?x=<span class=\"hljs-subst\">${x}</span>&#x26;y=<span class=\"hljs-subst\">${y}</span>&#x26;width=<span class=\"hljs-subst\">${width}</span>&#x26;height=<span class=\"hljs-subst\">${height}</span>`</span>;\n    });\n  </span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">html</span>></span>\n</code></pre>\n<ul>\n<li>detail.html</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&#x3C;!DOCTYPE <span class=\"hljs-keyword\">html</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">head</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"IE=edge\"</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span> /></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">title</span>></span>Detail<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">title</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">style</span>></span><span class=\"css\">\n      * {\n        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;\n      }\n      <span class=\"hljs-selector-tag\">body</span> {\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100vw</span>;\n        <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100vh</span>;\n      }\n      <span class=\"hljs-selector-id\">#detail-content</span> {\n        <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">10vw</span>;\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">80vw</span>;\n        <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">80vh</span>;\n        <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#333</span>;\n        <span class=\"hljs-attribute\">text-align</span>: center;\n        <span class=\"hljs-attribute\">color</span>: blue;\n      }\n    </span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">style</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">head</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">body</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"detail-content\"</span>></span>商品详情<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">body</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n    <span class=\"hljs-comment\">// 获取路由参数</span>\n    <span class=\"hljs-keyword\">const</span> query = location.<span class=\"hljs-property\">href</span>\n      .<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">\"?\"</span>)[<span class=\"hljs-number\">1</span>]\n      .<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">\"&#x26;\"</span>)\n      .<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">obj, str</span>) =></span> {\n        obj[str.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">\"=\"</span>)[<span class=\"hljs-number\">0</span>]] = str.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">\"=\"</span>)[<span class=\"hljs-number\">1</span>];\n        <span class=\"hljs-keyword\">return</span> obj;\n      }, {});\n\n    <span class=\"hljs-comment\">// 页面加载完成后执行动画</span>\n    <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">onload</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">const</span> target = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"detail-content\"</span>);\n      <span class=\"hljs-keyword\">const</span> { x, y, width, height } = target.<span class=\"hljs-title function_\">getBoundingClientRect</span>();\n      <span class=\"hljs-keyword\">const</span> options = {\n        <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">1000</span>,\n        <span class=\"hljs-attr\">easing</span>: <span class=\"hljs-string\">\"cubic-bezier(0,0,0.32,1)\"</span>,\n      };\n\n      <span class=\"hljs-comment\">// 执行动画</span>\n      target.<span class=\"hljs-title function_\">animate</span>(\n        [\n          {\n            <span class=\"hljs-attr\">transform</span>: <span class=\"hljs-string\">`translate(<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">Number</span>(query.x) - x}</span>px, <span class=\"hljs-subst\">${\n              <span class=\"hljs-built_in\">Number</span>(query.y) - y\n            }</span>px)`</span>,\n            <span class=\"hljs-attr\">width</span>: query.<span class=\"hljs-property\">width</span> + <span class=\"hljs-string\">\"px\"</span>,\n            <span class=\"hljs-attr\">height</span>: query.<span class=\"hljs-property\">height</span> + <span class=\"hljs-string\">\"px\"</span>,\n          },\n          {\n            <span class=\"hljs-attr\">transform</span>: <span class=\"hljs-string\">\"translate(0, 0)\"</span>,\n            width,\n            height,\n          },\n        ],\n        options\n      );\n    };\n  </span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">html</span>></span>\n</code></pre>\n<p>核心的思路是：通过 url 记录和传递点击卡片的信息给详情页面，详情页面加载完成之后，执行动画。先回到上个页面卡片点击的状态（位置、大小），动画执行过程中再过渡到现在的详情页面状态（位置、大小）。</p>",
            "url": "https://chennlang.github.io/post/what-flip/",
            "title": "FLIP 动画原理-图文详解",
            "date_modified": "2023-02-13T00:00:00.000Z",
            "author": {
                "name": "Alang' Blog",
                "url": "https://chennlang.github.io"
            }
        }
    ]
}